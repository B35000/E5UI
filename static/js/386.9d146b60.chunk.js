"use strict";(self.webpackChunkold_e5=self.webpackChunkold_e5||[]).push([[386],{6386:(t,e,a)=>{a.r(e),a.d(e,{DsdiffContentParseError:()=>d,DsdiffParser:()=>u});var n=a(26784),i=a(9382),s=a(88359),o=a(76124),r=a(81705),c=a(9634);const h={len:12,get:(t,e)=>({chunkID:o.e.get(t,e),chunkSize:n.INT64_BE.get(t,e+4)})};var k=a(16669);const m=i("music-metadata:parser:aiff");class d extends((0,k.fO)("DSDIFF")){}class u extends r.s{async parse(){const t=await this.tokenizer.readToken(h);if("FRM8"!==t.chunkID)throw new d("Unexpected chunk-ID");const e=(await this.tokenizer.readToken(o.e)).trim();if("DSD"===e)return this.metadata.setFormat("container","DSDIFF/".concat(e)),this.metadata.setFormat("lossless",!0),this.readFmt8Chunks(t.chunkSize-BigInt(o.e.len));throw new d("Unsupported DSDIFF type: ".concat(e))}async readFmt8Chunks(t){for(;t>=h.len;){const e=await this.tokenizer.readToken(h);m("Chunk id=".concat(e.chunkID)),await this.readData(e),t-=BigInt(h.len)+e.chunkSize}}async readData(t){m("Reading data of chunk[ID=".concat(t.chunkID,", size=").concat(t.chunkSize,"]"));const e=this.tokenizer.position;switch(t.chunkID.trim()){case"FVER":{const t=await this.tokenizer.readToken(n.UINT32_LE);m("DSDIFF version=".concat(t));break}case"PROP":if("SND "!==await this.tokenizer.readToken(o.e))throw new d("Unexpected PROP-chunk ID");await this.handleSoundPropertyChunks(t.chunkSize-BigInt(o.e.len));break;case"ID3":{const e=await this.tokenizer.readToken(new n.Uint8ArrayType(Number(t.chunkSize))),a=s.vY(e);await(new c.S).parse(this.metadata,a,this.options);break}case"DSD":this.metadata.format.numberOfChannels&&this.metadata.setFormat("numberOfSamples",Number(t.chunkSize*BigInt(8)/BigInt(this.metadata.format.numberOfChannels))),this.metadata.format.numberOfSamples&&this.metadata.format.sampleRate&&this.metadata.setFormat("duration",this.metadata.format.numberOfSamples/this.metadata.format.sampleRate);break;default:m("Ignore chunk[ID=".concat(t.chunkID,", size=").concat(t.chunkSize,"]"))}const a=t.chunkSize-BigInt(this.tokenizer.position-e);a>0&&(m("After Parsing chunk, remaining ".concat(a," bytes")),await this.tokenizer.ignore(Number(a)))}async handleSoundPropertyChunks(t){for(m("Parsing sound-property-chunks, remainingSize=".concat(t));t>0;){const e=await this.tokenizer.readToken(h);m("Sound-property-chunk[ID=".concat(e.chunkID,", size=").concat(e.chunkSize,"]"));const a=this.tokenizer.position;switch(e.chunkID.trim()){case"FS":{const t=await this.tokenizer.readToken(n.UINT32_BE);this.metadata.setFormat("sampleRate",t);break}case"CHNL":{const t=await this.tokenizer.readToken(n.UINT16_BE);this.metadata.setFormat("numberOfChannels",t),await this.handleChannelChunks(e.chunkSize-BigInt(n.UINT16_BE.len));break}case"CMPR":{const t=(await this.tokenizer.readToken(o.e)).trim(),e=await this.tokenizer.readToken(n.UINT8),a=await this.tokenizer.readToken(new n.StringType(e,"ascii"));"DSD"===t&&(this.metadata.setFormat("lossless",!0),this.metadata.setFormat("bitsPerSample",1)),this.metadata.setFormat("codec","".concat(t," (").concat(a,")"));break}case"ABSS":{const t=await this.tokenizer.readToken(n.UINT16_BE),e=await this.tokenizer.readToken(n.UINT8),a=await this.tokenizer.readToken(n.UINT8),i=await this.tokenizer.readToken(n.UINT32_BE);m("ABSS ".concat(t,":").concat(e,":").concat(a,".").concat(i));break}case"LSCO":{const t=await this.tokenizer.readToken(n.UINT16_BE);m("LSCO lsConfig=".concat(t));break}default:m("Unknown sound-property-chunk[ID=".concat(e.chunkID,", size=").concat(e.chunkSize,"]")),await this.tokenizer.ignore(Number(e.chunkSize))}const i=e.chunkSize-BigInt(this.tokenizer.position-a);i>0&&(m("After Parsing sound-property-chunk ".concat(e.chunkSize,", remaining ").concat(i," bytes")),await this.tokenizer.ignore(Number(i))),t-=BigInt(h.len)+e.chunkSize,m("Parsing sound-property-chunks, remainingSize=".concat(t))}if(this.metadata.format.lossless&&this.metadata.format.sampleRate&&this.metadata.format.numberOfChannels&&this.metadata.format.bitsPerSample){const t=this.metadata.format.sampleRate*this.metadata.format.numberOfChannels*this.metadata.format.bitsPerSample;this.metadata.setFormat("bitrate",t)}}async handleChannelChunks(t){m("Parsing channel-chunks, remainingSize=".concat(t));const e=[];for(;t>=o.e.len;){const a=await this.tokenizer.readToken(o.e);m("Channel[ID=".concat(a,"]")),e.push(a),t-=BigInt(o.e.len)}return m("Channels: ".concat(e.join(", "))),e}}}}]);