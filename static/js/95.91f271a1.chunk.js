"use strict";(self.webpackChunkold_e5=self.webpackChunkold_e5||[]).push([[95],{50095(e,t,a){a.r(t),a.d(t,{AIFFParser:()=>k});var s=a(70124),i=a(81760),n=a(26041),o=a(45038),r=a(90070),c=a(56067),h=a(92419);const m={NONE:"not compressed\tPCM\tApple Computer",sowt:"PCM (byte swapped)",fl32:"32-bit floating point IEEE 32-bit float",fl64:"64-bit floating point IEEE 64-bit float\tApple Computer",alaw:"ALaw 2:1\t8-bit ITU-T G.711 A-law",ulaw:"\xb5Law 2:1\t8-bit ITU-T G.711 \xb5-law\tApple Computer",ULAW:"CCITT G.711 u-law 8-bit ITU-T G.711 \xb5-law",ALAW:"CCITT G.711 A-law 8-bit ITU-T G.711 A-law",FL32:"Float 32\tIEEE 32-bit float "};class l extends((0,h.fO)("AIFF")){}class p{constructor(e,t){this.isAifc=t;const a=t?22:18;if(e.chunkSize<a)throw new l("COMMON CHUNK size should always be at least ".concat(a));this.len=e.chunkSize}get(e,t){const a=s.UINT16_BE.get(e,t+8)-16398,i=s.UINT16_BE.get(e,t+8+2),n={numChannels:s.UINT16_BE.get(e,t),numSampleFrames:s.UINT32_BE.get(e,t+2),sampleSize:s.UINT16_BE.get(e,t+6),sampleRate:a<0?i>>Math.abs(a):i<<a};if(this.isAifc){if(n.compressionType=r.e.get(e,t+18),this.len>22){const a=s.UINT8.get(e,t+22);if(a>0){if(23+a+(a+1)%2!==this.len)throw new l("Illegal pstring length");n.compressionName=new s.StringType(a,"latin1").get(e,t+23)}else n.compressionName=void 0}}else n.compressionName="PCM";return n}}const u={len:8,get:(e,t)=>({chunkID:r.e.get(e,t),chunkSize:Number(BigInt(s.UINT32_BE.get(e,t+4)))})},d=i("music-metadata:parser:aiff");class k extends c.s{constructor(){super(...arguments),this.isCompressed=null}async parse(){if("FORM"!==(await this.tokenizer.readToken(u)).chunkID)throw new l("Invalid Chunk-ID, expected 'FORM'");const e=await this.tokenizer.readToken(r.e);switch(e){case"AIFF":this.metadata.setFormat("container",e),this.isCompressed=!1;break;case"AIFC":this.metadata.setFormat("container","AIFF-C"),this.isCompressed=!0;break;default:throw new l("Unsupported AIFF type: ".concat(e))}this.metadata.setFormat("lossless",!this.isCompressed);try{for(;!this.tokenizer.fileInfo.size||this.tokenizer.fileInfo.size-this.tokenizer.position>=u.len;){d("Reading AIFF chunk at offset=".concat(this.tokenizer.position));const e=await this.tokenizer.readToken(u),t=2*Math.round(e.chunkSize/2),a=await this.readData(e);await this.tokenizer.ignore(t-a)}}catch(t){if(!(t instanceof n.d1))throw t;d("End-of-stream")}}async readData(e){switch(e.chunkID){case"COMM":{if(null===this.isCompressed)throw new l("Failed to parse AIFF.COMM chunk when compression type is unknown");const a=await this.tokenizer.readToken(new p(e,this.isCompressed));var t;if(this.metadata.setFormat("bitsPerSample",a.sampleSize),this.metadata.setFormat("sampleRate",a.sampleRate),this.metadata.setFormat("numberOfChannels",a.numChannels),this.metadata.setFormat("numberOfSamples",a.numSampleFrames),this.metadata.setFormat("duration",a.numSampleFrames/a.sampleRate),a.compressionName||a.compressionType)this.metadata.setFormat("codec",null!==(t=a.compressionName)&&void 0!==t?t:m[a.compressionType]);return e.chunkSize}case"ID3 ":{const t=await this.tokenizer.readToken(new s.Uint8ArrayType(e.chunkSize)),a=n.vY(t);return await(new o.S).parse(this.metadata,a,this.options),e.chunkSize}case"SSND":return this.metadata.format.duration&&this.metadata.setFormat("bitrate",8*e.chunkSize/this.metadata.format.duration),0;case"NAME":case"AUTH":case"(c) ":case"ANNO":return this.readTextChunk(e);default:return d("Ignore chunk id=".concat(e.chunkID,", size=").concat(e.chunkSize)),0}}async readTextChunk(e){const t=(await this.tokenizer.readToken(new s.StringType(e.chunkSize,"ascii"))).split("\0").map(e=>e.trim()).filter(e=>null===e||void 0===e?void 0:e.length);return await Promise.all(t.map(t=>this.metadata.addTag("AIFF",e.chunkID,t))),e.chunkSize}}}}]);