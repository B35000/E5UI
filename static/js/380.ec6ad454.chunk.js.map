{"version":3,"file":"static/js/380.ec6ad454.chunk.js","mappings":"2MAKO,MAAMA,EAAc,CACvBC,IAAK,GACLC,IAAKA,CAACC,EAAKC,KACA,CAAEC,GAAIC,EAAAA,EAAYJ,IAAIC,EAAKC,GAAMG,KAAMC,EAAAA,UAAgBN,IAAIC,EAAKC,EAAM,MAMxEK,EAAW,CACpBR,IAAK,GACLC,IAAKA,CAACC,EAAKC,KACA,CACHM,SAAUF,EAAAA,SAAeN,IAAIC,EAAKC,GAClCO,gBAAiBH,EAAAA,SAAeN,IAAIC,EAAKC,EAAM,MAIpD,IAAIQ,GACX,SAAWA,GACPA,EAAYA,EAAkB,KAAI,GAAK,OACvCA,EAAYA,EAAoB,OAAI,GAAK,SACzCA,EAAYA,EAAsB,SAAI,GAAK,WAC3CA,EAAYA,EAAkB,KAAI,GAAK,OACvCA,EAAYA,EAAY,cAAgB,GAAK,aAC7CA,EAAYA,EAAY,cAAgB,GAAK,aAC7CA,EAAYA,EAAY,gBAAkB,GAAK,cAClD,CARD,CAQGA,IAAgBA,EAAc,CAAC,IAI3B,MAAMC,EAAc,CACvBZ,IAAK,GACLC,IAAKA,CAACC,EAAKC,KACA,CACHU,cAAeN,EAAAA,SAAeN,IAAIC,EAAKC,GACvCW,SAAUP,EAAAA,SAAeN,IAAIC,EAAKC,EAAM,GACxCY,YAAaR,EAAAA,SAAeN,IAAIC,EAAKC,EAAM,GAC3Ca,WAAYT,EAAAA,SAAeN,IAAIC,EAAKC,EAAM,IAC1Cc,kBAAmBV,EAAAA,SAAeN,IAAIC,EAAKC,EAAM,IACjDe,cAAeX,EAAAA,SAAeN,IAAIC,EAAKC,EAAM,IAC7CgB,YAAaZ,EAAAA,SAAeN,IAAIC,EAAKC,EAAM,IAC3CiB,oBAAqBb,EAAAA,SAAeN,IAAIC,EAAKC,EAAM,O,0BC1C/D,MAAMkB,EAAQC,EAAU,6BACjB,MAAMC,WAA6BC,EAAAA,EAAAA,IAA+B,SAMlE,MAAMC,UAAkBC,EAAAA,EAC3B,oBAAMC,GACF,MAAMC,EAAKC,KAAKC,UAAUC,SACpBC,QAAoBH,KAAKC,UAAUG,UAAUlC,GACnD,GAAuB,SAAnBiC,EAAY5B,GACZ,MAAM,IAAImB,EAAqB,2BACnCM,KAAKK,SAASC,UAAU,YAAa,OACrCN,KAAKK,SAASC,UAAU,YAAY,GACpC,MAAMC,QAAiBP,KAAKC,UAAUG,UAAUzB,GAChD,GAAI4B,EAAS1B,kBAAoB2B,OAAO,GAQpC,OAJAhB,EAAM,0BAA0Be,EAAS1B,yBACnCmB,KAAKS,YAAYF,EAAS3B,SAAWuB,EAAY1B,YAEjDuB,KAAKC,UAAUS,OAAOC,OAAOJ,EAAS1B,iBAAmBmB,KAAKC,UAAUC,SAAWH,IAClF,IAAIa,EAAAA,GAAcC,MAAMb,KAAKK,SAAUL,KAAKC,UAAWD,KAAKc,SAPnEtB,EAAM,uBASd,CACA,iBAAMiB,CAAYM,GACd,KAAOA,GAAkB7C,EAAYC,KAAK,CACtC,MAAMgC,QAAoBH,KAAKC,UAAUG,UAAUlC,GAEnD,GADAsB,EAAM,sBAAsBW,EAAY5B,WAAW4B,EAAY1B,QAEtD,SADD0B,EAAY5B,GACH,CACT,MAAMyC,QAAoBhB,KAAKC,UAAUG,UAAUrB,GACnDiB,KAAKK,SAASC,UAAU,mBAAoBU,EAAY7B,YACxDa,KAAKK,SAASC,UAAU,aAAcU,EAAY5B,mBAClDY,KAAKK,SAASC,UAAU,gBAAiBU,EAAY3B,eACrDW,KAAKK,SAASC,UAAU,kBAAmBU,EAAY1B,aACvDU,KAAKK,SAASC,UAAU,WAAYK,OAAOK,EAAY1B,aAAe0B,EAAY5B,mBAClF,MAAM6B,EAAUD,EAAY3B,cAAgB2B,EAAY5B,kBAAoB4B,EAAY7B,WAExF,YADAa,KAAKK,SAASC,UAAU,UAAWW,EAEvC,CAEIjB,KAAKC,UAAUS,OAAOC,OAAOR,EAAY1B,MAAQP,EAAYC,KAGrE4C,GAAkBZ,EAAY1B,IAClC,CACJ,E,wGChDJ,MAAMe,EAAQC,EAAU,6BAIjB,MAAMI,UAA0BqB,EAAAA,EACnCC,WAAAA,GACIC,SAASC,WACTrB,KAAKsB,UAAY,IAAIV,EAAAA,CACzB,CACA,kCAAaW,CAAsBtB,GAC/B,MAAmE,eAArDA,EAAUuB,UAAUC,EAAAA,KAAcC,cACpD,CACA,WAAMb,GACF,UACUb,KAAK2B,YACf,CACA,MAAOC,GACH,KAAIA,aAAeC,EAAAA,IAIf,MAAMD,EAHNpC,EAAM,gBAKd,CACJ,CACAsC,QAAAA,GAEA,CACA,gBAAMH,GAIF,SAHM3B,KAAK+B,sBACXvC,EAAM,iDAAkDQ,KAAKC,UAAUC,gBACjEF,KAAKF,iBACPE,KAAKc,QAAQkB,iBAAmBhC,KAAKK,SAAS4B,SAC9CjC,KAAK8B,eAEJ,CACD,MAAMI,EAAc,IAAIC,EAAAA,GAAYnC,KAAKK,SAAUL,KAAKC,UAAWD,KAAKc,eAClEoB,EAAYrB,QAClBb,KAAK8B,UACT,CACJ,CACA,yBAAMC,GAEF,GAAiC,eADT/B,KAAKC,UAAUuB,UAAUC,EAAAA,KACnCC,eAGV,OAFAlC,EAAM,6BAA8BQ,KAAKC,UAAUC,gBAC7CF,KAAKsB,UAAUT,MAAMb,KAAKK,SAAUL,KAAKC,UAAWD,KAAKc,SACxDd,KAAK+B,qBAEpB,E","sources":["../node_modules/music-metadata/lib/dsf/DsfChunk.js","../node_modules/music-metadata/lib/dsf/DsfParser.js","../node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js"],"sourcesContent":["import * as Token from 'token-types';\nimport { FourCcToken } from '../common/FourCC.js';\n/**\n * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size\n */\nexport const ChunkHeader = {\n    len: 12,\n    get: (buf, off) => {\n        return { id: FourCcToken.get(buf, off), size: Token.UINT64_LE.get(buf, off + 4) };\n    }\n};\n/**\n * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size\n */\nexport const DsdChunk = {\n    len: 16,\n    get: (buf, off) => {\n        return {\n            fileSize: Token.INT64_LE.get(buf, off),\n            metadataPointer: Token.INT64_LE.get(buf, off + 8)\n        };\n    }\n};\nexport var ChannelType;\n(function (ChannelType) {\n    ChannelType[ChannelType[\"mono\"] = 1] = \"mono\";\n    ChannelType[ChannelType[\"stereo\"] = 2] = \"stereo\";\n    ChannelType[ChannelType[\"channels\"] = 3] = \"channels\";\n    ChannelType[ChannelType[\"quad\"] = 4] = \"quad\";\n    ChannelType[ChannelType[\"4 channels\"] = 5] = \"4 channels\";\n    ChannelType[ChannelType[\"5 channels\"] = 6] = \"5 channels\";\n    ChannelType[ChannelType[\"5.1 channels\"] = 7] = \"5.1 channels\";\n})(ChannelType || (ChannelType = {}));\n/**\n * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size\n */\nexport const FormatChunk = {\n    len: 40,\n    get: (buf, off) => {\n        return {\n            formatVersion: Token.INT32_LE.get(buf, off),\n            formatID: Token.INT32_LE.get(buf, off + 4),\n            channelType: Token.INT32_LE.get(buf, off + 8),\n            channelNum: Token.INT32_LE.get(buf, off + 12),\n            samplingFrequency: Token.INT32_LE.get(buf, off + 16),\n            bitsPerSample: Token.INT32_LE.get(buf, off + 20),\n            sampleCount: Token.INT64_LE.get(buf, off + 24),\n            blockSizePerChannel: Token.INT32_LE.get(buf, off + 32)\n        };\n    }\n};\n//# sourceMappingURL=DsfChunk.js.map","import initDebug from 'debug';\nimport { AbstractID3Parser } from '../id3v2/AbstractID3Parser.js';\nimport { ChunkHeader, DsdChunk, FormatChunk } from './DsfChunk.js';\nimport { ID3v2Parser } from \"../id3v2/ID3v2Parser.js\";\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nconst debug = initDebug('music-metadata:parser:DSF');\nexport class DsdContentParseError extends makeUnexpectedFileContentError('DSD') {\n}\n/**\n * DSF (dsd stream file) File Parser\n * Ref: https://dsd-guide.com/sites/default/files/white-papers/DSFFileFormatSpec_E.pdf\n */\nexport class DsfParser extends AbstractID3Parser {\n    async postId3v2Parse() {\n        const p0 = this.tokenizer.position; // mark start position, normally 0\n        const chunkHeader = await this.tokenizer.readToken(ChunkHeader);\n        if (chunkHeader.id !== 'DSD ')\n            throw new DsdContentParseError('Invalid chunk signature');\n        this.metadata.setFormat('container', 'DSF');\n        this.metadata.setFormat('lossless', true);\n        const dsdChunk = await this.tokenizer.readToken(DsdChunk);\n        if (dsdChunk.metadataPointer === BigInt(0)) {\n            debug(\"No ID3v2 tag present\");\n        }\n        else {\n            debug(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`);\n            await this.parseChunks(dsdChunk.fileSize - chunkHeader.size);\n            // Jump to ID3 header\n            await this.tokenizer.ignore(Number(dsdChunk.metadataPointer) - this.tokenizer.position - p0);\n            return new ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);\n        }\n    }\n    async parseChunks(bytesRemaining) {\n        while (bytesRemaining >= ChunkHeader.len) {\n            const chunkHeader = await this.tokenizer.readToken(ChunkHeader);\n            debug(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`);\n            switch (chunkHeader.id) {\n                case 'fmt ': {\n                    const formatChunk = await this.tokenizer.readToken(FormatChunk);\n                    this.metadata.setFormat('numberOfChannels', formatChunk.channelNum);\n                    this.metadata.setFormat('sampleRate', formatChunk.samplingFrequency);\n                    this.metadata.setFormat('bitsPerSample', formatChunk.bitsPerSample);\n                    this.metadata.setFormat('numberOfSamples', formatChunk.sampleCount);\n                    this.metadata.setFormat('duration', Number(formatChunk.sampleCount) / formatChunk.samplingFrequency);\n                    const bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;\n                    this.metadata.setFormat('bitrate', bitrate);\n                    return; // We got what we want, stop further processing of chunks\n                }\n                default:\n                    this.tokenizer.ignore(Number(chunkHeader.size) - ChunkHeader.len);\n                    break;\n            }\n            bytesRemaining -= chunkHeader.size;\n        }\n    }\n}\n//# sourceMappingURL=DsfParser.js.map","import { EndOfStreamError } from 'strtok3';\nimport initDebug from 'debug';\nimport { ID3v2Header } from './ID3v2Token.js';\nimport { ID3v2Parser } from './ID3v2Parser.js';\nimport { ID3v1Parser } from '../id3v1/ID3v1Parser.js';\nimport { BasicParser } from '../common/BasicParser.js';\nconst debug = initDebug('music-metadata:parser:ID3');\n/**\n * Abstract parser which tries take ID3v2 and ID3v1 headers.\n */\nexport class AbstractID3Parser extends BasicParser {\n    constructor() {\n        super(...arguments);\n        this.id3parser = new ID3v2Parser();\n    }\n    static async startsWithID3v2Header(tokenizer) {\n        return (await tokenizer.peekToken(ID3v2Header)).fileIdentifier === 'ID3';\n    }\n    async parse() {\n        try {\n            await this.parseID3v2();\n        }\n        catch (err) {\n            if (err instanceof EndOfStreamError) {\n                debug(\"End-of-stream\");\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    finalize() {\n        return;\n    }\n    async parseID3v2() {\n        await this.tryReadId3v2Headers();\n        debug('End of ID3v2 header, go to MPEG-parser: pos=%s', this.tokenizer.position);\n        await this.postId3v2Parse();\n        if (this.options.skipPostHeaders && this.metadata.hasAny()) {\n            this.finalize();\n        }\n        else {\n            const id3v1parser = new ID3v1Parser(this.metadata, this.tokenizer, this.options);\n            await id3v1parser.parse();\n            this.finalize();\n        }\n    }\n    async tryReadId3v2Headers() {\n        const id3Header = await this.tokenizer.peekToken(ID3v2Header);\n        if (id3Header.fileIdentifier === 'ID3') {\n            debug('Found ID3v2 header, pos=%s', this.tokenizer.position);\n            await this.id3parser.parse(this.metadata, this.tokenizer, this.options);\n            return this.tryReadId3v2Headers();\n        }\n    }\n}\n//# sourceMappingURL=AbstractID3Parser.js.map"],"names":["ChunkHeader","len","get","buf","off","id","FourCcToken","size","Token","DsdChunk","fileSize","metadataPointer","ChannelType","FormatChunk","formatVersion","formatID","channelType","channelNum","samplingFrequency","bitsPerSample","sampleCount","blockSizePerChannel","debug","initDebug","DsdContentParseError","makeUnexpectedFileContentError","DsfParser","AbstractID3Parser","postId3v2Parse","p0","this","tokenizer","position","chunkHeader","readToken","metadata","setFormat","dsdChunk","BigInt","parseChunks","ignore","Number","ID3v2Parser","parse","options","bytesRemaining","formatChunk","bitrate","BasicParser","constructor","super","arguments","id3parser","startsWithID3v2Header","peekToken","ID3v2Header","fileIdentifier","parseID3v2","err","EndOfStreamError","finalize","tryReadId3v2Headers","skipPostHeaders","hasAny","id3v1parser","ID3v1Parser"],"sourceRoot":""}