{"version":3,"file":"static/js/643.e94e321c.chunk.js","mappings":"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","sources":["../node_modules/music-metadata/lib/dsdiff/DsdiffToken.js","../node_modules/music-metadata/lib/dsdiff/DsdiffParser.js"],"sourcesContent":["import * as Token from 'token-types';\nimport { FourCcToken } from '../common/FourCC.js';\n/**\n * DSDIFF chunk header\n * The data-size encoding is deviating from EA-IFF 85\n * Ref: http://www.sonicstudio.com/pdf/dsd/DSDIFF_1.5_Spec.pdf\n */\nexport const ChunkHeader64 = {\n    len: 12,\n    get: (buf, off) => {\n        return {\n            // Group-ID\n            chunkID: FourCcToken.get(buf, off),\n            // Size\n            chunkSize: Token.INT64_BE.get(buf, off + 4)\n        };\n    }\n};\n//# sourceMappingURL=DsdiffToken.js.map","import * as Token from 'token-types';\nimport initDebug from 'debug';\nimport * as strtok3 from 'strtok3';\nimport { FourCcToken } from '../common/FourCC.js';\nimport { BasicParser } from '../common/BasicParser.js';\nimport { ID3v2Parser } from '../id3v2/ID3v2Parser.js';\nimport { ChunkHeader64 } from './DsdiffToken.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nconst debug = initDebug('music-metadata:parser:aiff');\nexport class DsdiffContentParseError extends makeUnexpectedFileContentError('DSDIFF') {\n}\n/**\n * DSDIFF - Direct Stream Digital Interchange File Format (Phillips)\n *\n * Ref:\n * - http://www.sonicstudio.com/pdf/dsd/DSDIFF_1.5_Spec.pdf\n */\nexport class DsdiffParser extends BasicParser {\n    async parse() {\n        const header = await this.tokenizer.readToken(ChunkHeader64);\n        if (header.chunkID !== 'FRM8')\n            throw new DsdiffContentParseError('Unexpected chunk-ID');\n        const type = (await this.tokenizer.readToken(FourCcToken)).trim();\n        switch (type) {\n            case 'DSD':\n                this.metadata.setFormat('container', `DSDIFF/${type}`);\n                this.metadata.setFormat('lossless', true);\n                return this.readFmt8Chunks(header.chunkSize - BigInt(FourCcToken.len));\n            default:\n                throw new DsdiffContentParseError(`Unsupported DSDIFF type: ${type}`);\n        }\n    }\n    async readFmt8Chunks(remainingSize) {\n        while (remainingSize >= ChunkHeader64.len) {\n            const chunkHeader = await this.tokenizer.readToken(ChunkHeader64);\n            //  If the data is an odd number of bytes in length, a pad byte must be added at the end\n            debug(`Chunk id=${chunkHeader.chunkID}`);\n            await this.readData(chunkHeader);\n            remainingSize -= (BigInt(ChunkHeader64.len) + chunkHeader.chunkSize);\n        }\n    }\n    async readData(header) {\n        debug(`Reading data of chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\n        const p0 = this.tokenizer.position;\n        switch (header.chunkID.trim()) {\n            case 'FVER': { // 3.1 FORMAT VERSION CHUNK\n                const version = await this.tokenizer.readToken(Token.UINT32_LE);\n                debug(`DSDIFF version=${version}`);\n                break;\n            }\n            case 'PROP': { // 3.2 PROPERTY CHUNK\n                const propType = await this.tokenizer.readToken(FourCcToken);\n                if (propType !== 'SND ')\n                    throw new DsdiffContentParseError('Unexpected PROP-chunk ID');\n                await this.handleSoundPropertyChunks(header.chunkSize - BigInt(FourCcToken.len));\n                break;\n            }\n            case 'ID3': { // Unofficial ID3 tag support\n                const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(Number(header.chunkSize)));\n                const rst = strtok3.fromBuffer(id3_data);\n                await new ID3v2Parser().parse(this.metadata, rst, this.options);\n                break;\n            }\n            case 'DSD':\n                if (this.metadata.format.numberOfChannels) {\n                    this.metadata.setFormat('numberOfSamples', Number(header.chunkSize * BigInt(8) / BigInt(this.metadata.format.numberOfChannels)));\n                }\n                if (this.metadata.format.numberOfSamples && this.metadata.format.sampleRate) {\n                    this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\n                }\n                break;\n            default:\n                debug(`Ignore chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\n                break;\n        }\n        const remaining = header.chunkSize - BigInt(this.tokenizer.position - p0);\n        if (remaining > 0) {\n            debug(`After Parsing chunk, remaining ${remaining} bytes`);\n            await this.tokenizer.ignore(Number(remaining));\n        }\n    }\n    async handleSoundPropertyChunks(remainingSize) {\n        debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\n        while (remainingSize > 0) {\n            const sndPropHeader = await this.tokenizer.readToken(ChunkHeader64);\n            debug(`Sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\n            const p0 = this.tokenizer.position;\n            switch (sndPropHeader.chunkID.trim()) {\n                case 'FS': { // 3.2.1 Sample Rate Chunk\n                    const sampleRate = await this.tokenizer.readToken(Token.UINT32_BE);\n                    this.metadata.setFormat('sampleRate', sampleRate);\n                    break;\n                }\n                case 'CHNL': { // 3.2.2 Channels Chunk\n                    const numChannels = await this.tokenizer.readToken(Token.UINT16_BE);\n                    this.metadata.setFormat('numberOfChannels', numChannels);\n                    await this.handleChannelChunks(sndPropHeader.chunkSize - BigInt(Token.UINT16_BE.len));\n                    break;\n                }\n                case 'CMPR': { // 3.2.3 Compression Type Chunk\n                    const compressionIdCode = (await this.tokenizer.readToken(FourCcToken)).trim();\n                    const count = await this.tokenizer.readToken(Token.UINT8);\n                    const compressionName = await this.tokenizer.readToken(new Token.StringType(count, 'ascii'));\n                    if (compressionIdCode === 'DSD') {\n                        this.metadata.setFormat('lossless', true);\n                        this.metadata.setFormat('bitsPerSample', 1);\n                    }\n                    this.metadata.setFormat('codec', `${compressionIdCode} (${compressionName})`);\n                    break;\n                }\n                case 'ABSS': { // 3.2.4 Absolute Start Time Chunk\n                    const hours = await this.tokenizer.readToken(Token.UINT16_BE);\n                    const minutes = await this.tokenizer.readToken(Token.UINT8);\n                    const seconds = await this.tokenizer.readToken(Token.UINT8);\n                    const samples = await this.tokenizer.readToken(Token.UINT32_BE);\n                    debug(`ABSS ${hours}:${minutes}:${seconds}.${samples}`);\n                    break;\n                }\n                case 'LSCO': { // 3.2.5 Loudspeaker Configuration Chunk\n                    const lsConfig = await this.tokenizer.readToken(Token.UINT16_BE);\n                    debug(`LSCO lsConfig=${lsConfig}`);\n                    break;\n                }\n                default:\n                    debug(`Unknown sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\n                    await this.tokenizer.ignore(Number(sndPropHeader.chunkSize));\n            }\n            const remaining = sndPropHeader.chunkSize - BigInt(this.tokenizer.position - p0);\n            if (remaining > 0) {\n                debug(`After Parsing sound-property-chunk ${sndPropHeader.chunkSize}, remaining ${remaining} bytes`);\n                await this.tokenizer.ignore(Number(remaining));\n            }\n            remainingSize -= BigInt(ChunkHeader64.len) + sndPropHeader.chunkSize;\n            debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\n        }\n        if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {\n            const bitrate = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;\n            this.metadata.setFormat('bitrate', bitrate);\n        }\n    }\n    async handleChannelChunks(remainingSize) {\n        debug(`Parsing channel-chunks, remainingSize=${remainingSize}`);\n        const channels = [];\n        while (remainingSize >= FourCcToken.len) {\n            const channelId = await this.tokenizer.readToken(FourCcToken);\n            debug(`Channel[ID=${channelId}]`);\n            channels.push(channelId);\n            remainingSize -= BigInt(FourCcToken.len);\n        }\n        debug(`Channels: ${channels.join(', ')}`);\n        return channels;\n    }\n}\n//# sourceMappingURL=DsdiffParser.js.map"],"names":["ChunkHeader64","len","get","buf","off","chunkID","FourCcToken","chunkSize","Token","debug","initDebug","DsdiffContentParseError","makeUnexpectedFileContentError","DsdiffParser","BasicParser","parse","header","this","tokenizer","readToken","type","trim","metadata","setFormat","readFmt8Chunks","BigInt","remainingSize","chunkHeader","readData","p0","position","version","handleSoundPropertyChunks","id3_data","Number","rst","strtok3","ID3v2Parser","options","format","numberOfChannels","numberOfSamples","sampleRate","remaining","ignore","sndPropHeader","numChannels","handleChannelChunks","compressionIdCode","count","compressionName","hours","minutes","seconds","samples","lsConfig","lossless","bitsPerSample","bitrate","channels","channelId","push","join"],"sourceRoot":""}