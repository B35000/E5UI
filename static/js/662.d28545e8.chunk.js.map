{"version":3,"file":"static/js/662.d28545e8.chunk.js","mappings":"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","sources":["../node_modules/music-metadata/lib/riff/RiffChunk.js","../node_modules/music-metadata/lib/wav/WaveChunk.js","../node_modules/music-metadata/lib/wav/BwfChunk.js","../node_modules/music-metadata/lib/wav/WaveParser.js"],"sourcesContent":["import * as Token from 'token-types';\n/**\n * Common RIFF chunk header\n */\nexport const Header = {\n    len: 8,\n    get: (buf, off) => {\n        return {\n            // Group-ID\n            chunkID: new Token.StringType(4, 'latin1').get(buf, off),\n            // Size\n            chunkSize: Token.UINT32_LE.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Token to parse RIFF-INFO tag value\n */\nexport class ListInfoTagValue {\n    constructor(tagHeader) {\n        this.tagHeader = tagHeader;\n        this.len = tagHeader.chunkSize;\n        this.len += this.len & 1; // if it is an odd length, round up to even\n    }\n    get(buf, off) {\n        return new Token.StringType(this.tagHeader.chunkSize, 'ascii').get(buf, off);\n    }\n}\n//# sourceMappingURL=RiffChunk.js.map","import * as Token from 'token-types';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nexport class WaveContentError extends makeUnexpectedFileContentError('Wave') {\n}\n/**\n * Ref: https://msdn.microsoft.com/en-us/library/windows/desktop/dd317599(v=vs.85).aspx\n */\nexport var WaveFormat;\n(function (WaveFormat) {\n    WaveFormat[WaveFormat[\"PCM\"] = 1] = \"PCM\";\n    // MPEG-4 and AAC Audio Types\n    WaveFormat[WaveFormat[\"ADPCM\"] = 2] = \"ADPCM\";\n    WaveFormat[WaveFormat[\"IEEE_FLOAT\"] = 3] = \"IEEE_FLOAT\";\n    WaveFormat[WaveFormat[\"MPEG_ADTS_AAC\"] = 5632] = \"MPEG_ADTS_AAC\";\n    WaveFormat[WaveFormat[\"MPEG_LOAS\"] = 5634] = \"MPEG_LOAS\";\n    WaveFormat[WaveFormat[\"RAW_AAC1\"] = 255] = \"RAW_AAC1\";\n    // Dolby Audio Types\n    WaveFormat[WaveFormat[\"DOLBY_AC3_SPDIF\"] = 146] = \"DOLBY_AC3_SPDIF\";\n    WaveFormat[WaveFormat[\"DVM\"] = 8192] = \"DVM\";\n    WaveFormat[WaveFormat[\"RAW_SPORT\"] = 576] = \"RAW_SPORT\";\n    WaveFormat[WaveFormat[\"ESST_AC3\"] = 577] = \"ESST_AC3\";\n    WaveFormat[WaveFormat[\"DRM\"] = 9] = \"DRM\";\n    WaveFormat[WaveFormat[\"DTS2\"] = 8193] = \"DTS2\";\n    WaveFormat[WaveFormat[\"MPEG\"] = 80] = \"MPEG\";\n})(WaveFormat || (WaveFormat = {}));\n/**\n * format chunk; chunk-id is \"fmt \"\n * http://soundfile.sapp.org/doc/WaveFormat/\n */\nexport class Format {\n    constructor(header) {\n        if (header.chunkSize < 16)\n            throw new WaveContentError('Invalid chunk size');\n        this.len = header.chunkSize;\n    }\n    get(buf, off) {\n        return {\n            wFormatTag: Token.UINT16_LE.get(buf, off),\n            nChannels: Token.UINT16_LE.get(buf, off + 2),\n            nSamplesPerSec: Token.UINT32_LE.get(buf, off + 4),\n            nAvgBytesPerSec: Token.UINT32_LE.get(buf, off + 8),\n            nBlockAlign: Token.UINT16_LE.get(buf, off + 12),\n            wBitsPerSample: Token.UINT16_LE.get(buf, off + 14)\n        };\n    }\n}\n/**\n * Fact chunk; chunk-id is \"fact\"\n * http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html\n * http://www.recordingblogs.com/wiki/fact-chunk-of-a-wave-file\n */\nexport class FactChunk {\n    constructor(header) {\n        if (header.chunkSize < 4) {\n            throw new WaveContentError('Invalid fact chunk size.');\n        }\n        this.len = header.chunkSize;\n    }\n    get(buf, off) {\n        return {\n            dwSampleLength: Token.UINT32_LE.get(buf, off)\n        };\n    }\n}\n//# sourceMappingURL=WaveChunk.js.map","import * as Token from 'token-types';\nimport { stripNulls } from '../common/Util.js';\n/**\n * Broadcast Audio Extension Chunk\n * Ref: https://tech.ebu.ch/docs/tech/tech3285.pdf\n */\nexport const BroadcastAudioExtensionChunk = {\n    len: 420,\n    get: (uint8array, off) => {\n        return {\n            description: stripNulls(new Token.StringType(256, 'ascii').get(uint8array, off)).trim(),\n            originator: stripNulls(new Token.StringType(32, 'ascii').get(uint8array, off + 256)).trim(),\n            originatorReference: stripNulls(new Token.StringType(32, 'ascii').get(uint8array, off + 288)).trim(),\n            originationDate: stripNulls(new Token.StringType(10, 'ascii').get(uint8array, off + 320)).trim(),\n            originationTime: stripNulls(new Token.StringType(8, 'ascii').get(uint8array, off + 330)).trim(),\n            timeReferenceLow: Token.UINT32_LE.get(uint8array, off + 338),\n            timeReferenceHigh: Token.UINT32_LE.get(uint8array, off + 342),\n            version: Token.UINT16_LE.get(uint8array, off + 346),\n            umid: new Token.Uint8ArrayType(64).get(uint8array, off + 348),\n            loudnessValue: Token.UINT16_LE.get(uint8array, off + 412),\n            maxTruePeakLevel: Token.UINT16_LE.get(uint8array, off + 414),\n            maxMomentaryLoudness: Token.UINT16_LE.get(uint8array, off + 416),\n            maxShortTermLoudness: Token.UINT16_LE.get(uint8array, off + 418)\n        };\n    }\n};\n//# sourceMappingURL=BwfChunk.js.map","import * as strtok3 from 'strtok3';\nimport * as Token from 'token-types';\nimport initDebug from 'debug';\nimport * as riff from '../riff/RiffChunk.js';\nimport * as WaveChunk from './WaveChunk.js';\nimport { ID3v2Parser } from '../id3v2/ID3v2Parser.js';\nimport * as util from '../common/Util.js';\nimport { FourCcToken } from '../common/FourCC.js';\nimport { BasicParser } from '../common/BasicParser.js';\nimport { BroadcastAudioExtensionChunk } from './BwfChunk.js';\nimport { WaveContentError } from './WaveChunk.js';\nconst debug = initDebug('music-metadata:parser:RIFF');\n/**\n * Resource Interchange File Format (RIFF) Parser\n *\n * WAVE PCM soundfile format\n *\n * Ref:\n * - http://www.johnloomis.org/cpe102/asgn/asgn1/riff.html\n * - http://soundfile.sapp.org/doc/WaveFormat\n *\n * ToDo: Split WAVE part from RIFF parser\n */\nexport class WaveParser extends BasicParser {\n    constructor() {\n        super(...arguments);\n        this.blockAlign = 0;\n    }\n    async parse() {\n        const riffHeader = await this.tokenizer.readToken(riff.Header);\n        debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`);\n        if (riffHeader.chunkID !== 'RIFF')\n            return; // Not RIFF format\n        return this.parseRiffChunk(riffHeader.chunkSize).catch(err => {\n            if (!(err instanceof strtok3.EndOfStreamError)) {\n                throw err;\n            }\n        });\n    }\n    async parseRiffChunk(chunkSize) {\n        const type = await this.tokenizer.readToken(FourCcToken);\n        this.metadata.setFormat('container', type);\n        switch (type) {\n            case 'WAVE':\n                return this.readWaveChunk(chunkSize - FourCcToken.len);\n            default:\n                throw new WaveContentError(`Unsupported RIFF format: RIFF/${type}`);\n        }\n    }\n    async readWaveChunk(remaining) {\n        while (remaining >= riff.Header.len) {\n            const header = await this.tokenizer.readToken(riff.Header);\n            remaining -= riff.Header.len + header.chunkSize;\n            if (header.chunkSize > remaining) {\n                this.metadata.addWarning('Data chunk size exceeds file size');\n            }\n            this.header = header;\n            debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`);\n            switch (header.chunkID) {\n                case 'LIST':\n                    await this.parseListTag(header);\n                    break;\n                case 'fact': // extended Format chunk,\n                    this.metadata.setFormat('lossless', false);\n                    this.fact = await this.tokenizer.readToken(new WaveChunk.FactChunk(header));\n                    break;\n                case 'fmt ': { // The Util Chunk, non-PCM Formats\n                    const fmt = await this.tokenizer.readToken(new WaveChunk.Format(header));\n                    let subFormat = WaveChunk.WaveFormat[fmt.wFormatTag];\n                    if (!subFormat) {\n                        debug(`WAVE/non-PCM format=${fmt.wFormatTag}`);\n                        subFormat = `non-PCM (${fmt.wFormatTag})`;\n                    }\n                    this.metadata.setFormat('codec', subFormat);\n                    this.metadata.setFormat('bitsPerSample', fmt.wBitsPerSample);\n                    this.metadata.setFormat('sampleRate', fmt.nSamplesPerSec);\n                    this.metadata.setFormat('numberOfChannels', fmt.nChannels);\n                    this.metadata.setFormat('bitrate', fmt.nBlockAlign * fmt.nSamplesPerSec * 8);\n                    this.blockAlign = fmt.nBlockAlign;\n                    break;\n                }\n                case 'id3 ': // The way Picard, FooBar currently stores, ID3 meta-data\n                case 'ID3 ': { // The way Mp3Tags stores ID3 meta-data\n                    const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(header.chunkSize));\n                    const rst = strtok3.fromBuffer(id3_data);\n                    await new ID3v2Parser().parse(this.metadata, rst, this.options);\n                    break;\n                }\n                case 'data': { // PCM-data\n                    if (this.metadata.format.lossless !== false) {\n                        this.metadata.setFormat('lossless', true);\n                    }\n                    let chunkSize = header.chunkSize;\n                    if (this.tokenizer.fileInfo.size) {\n                        const calcRemaining = this.tokenizer.fileInfo.size - this.tokenizer.position;\n                        if (calcRemaining < chunkSize) {\n                            this.metadata.addWarning('data chunk length exceeding file length');\n                            chunkSize = calcRemaining;\n                        }\n                    }\n                    const numberOfSamples = this.fact ? this.fact.dwSampleLength : (chunkSize === 0xffffffff ? undefined : chunkSize / this.blockAlign);\n                    if (numberOfSamples) {\n                        this.metadata.setFormat('numberOfSamples', numberOfSamples);\n                        if (this.metadata.format.sampleRate) {\n                            this.metadata.setFormat('duration', numberOfSamples / this.metadata.format.sampleRate);\n                        }\n                    }\n                    if (this.metadata.format.codec === 'ADPCM') { // ADPCM is 4 bits lossy encoding resulting in 352kbps\n                        this.metadata.setFormat('bitrate', 352000);\n                    }\n                    else if (this.metadata.format.sampleRate) {\n                        this.metadata.setFormat('bitrate', this.blockAlign * this.metadata.format.sampleRate * 8);\n                    }\n                    await this.tokenizer.ignore(header.chunkSize);\n                    break;\n                }\n                case 'bext': { // Broadcast Audio Extension chunk\thttps://tech.ebu.ch/docs/tech/tech3285.pdf\n                    const bext = await this.tokenizer.readToken(BroadcastAudioExtensionChunk);\n                    Object.keys(bext).forEach(key => {\n                        this.metadata.addTag('exif', `bext.${key}`, bext[key]);\n                    });\n                    const bextRemaining = header.chunkSize - BroadcastAudioExtensionChunk.len;\n                    await this.tokenizer.ignore(bextRemaining);\n                    break;\n                }\n                case '\\x00\\x00\\x00\\x00': // padding ??\n                    debug(`Ignore padding chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\n                    this.metadata.addWarning(`Ignore chunk: RIFF/${header.chunkID}`);\n                    await this.tokenizer.ignore(header.chunkSize);\n                    break;\n                default:\n                    debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\n                    this.metadata.addWarning(`Ignore chunk: RIFF/${header.chunkID}`);\n                    await this.tokenizer.ignore(header.chunkSize);\n            }\n            if (this.header.chunkSize % 2 === 1) {\n                debug('Read odd padding byte'); // https://wiki.multimedia.cx/index.php/RIFF\n                await this.tokenizer.ignore(1);\n            }\n        }\n    }\n    async parseListTag(listHeader) {\n        const listType = await this.tokenizer.readToken(new Token.StringType(4, 'latin1'));\n        debug('pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s', this.tokenizer.position, listType);\n        switch (listType) {\n            case 'INFO':\n                return this.parseRiffInfoTags(listHeader.chunkSize - 4);\n            default:\n                this.metadata.addWarning(`Ignore chunk: RIFF/WAVE/LIST/${listType}`);\n                debug(`Ignoring chunkID=RIFF/WAVE/LIST/${listType}`);\n                return this.tokenizer.ignore(listHeader.chunkSize - 4).then();\n        }\n    }\n    async parseRiffInfoTags(chunkSize) {\n        while (chunkSize >= 8) {\n            const header = await this.tokenizer.readToken(riff.Header);\n            const valueToken = new riff.ListInfoTagValue(header);\n            const value = await this.tokenizer.readToken(valueToken);\n            this.addTag(header.chunkID, util.stripNulls(value));\n            chunkSize -= (8 + valueToken.len);\n        }\n        if (chunkSize !== 0) {\n            throw new WaveContentError(`Illegal remaining size: ${chunkSize}`);\n        }\n    }\n    addTag(id, value) {\n        this.metadata.addTag('exif', id, value);\n    }\n}\n//# sourceMappingURL=WaveParser.js.map"],"names":["Header","len","get","buf","off","chunkID","Token","chunkSize","ListInfoTagValue","constructor","tagHeader","this","WaveFormat","WaveContentError","makeUnexpectedFileContentError","Format","header","wFormatTag","nChannels","nSamplesPerSec","nAvgBytesPerSec","nBlockAlign","wBitsPerSample","FactChunk","dwSampleLength","BroadcastAudioExtensionChunk","uint8array","description","stripNulls","trim","originator","originatorReference","originationDate","originationTime","timeReferenceLow","timeReferenceHigh","version","umid","loudnessValue","maxTruePeakLevel","maxMomentaryLoudness","maxShortTermLoudness","debug","initDebug","WaveParser","BasicParser","super","arguments","blockAlign","parse","riffHeader","tokenizer","readToken","riff","position","parseRiffChunk","catch","err","strtok3","type","FourCcToken","metadata","setFormat","readWaveChunk","remaining","addWarning","parseListTag","fact","WaveChunk","fmt","subFormat","id3_data","rst","ID3v2Parser","options","format","lossless","fileInfo","size","calcRemaining","numberOfSamples","undefined","sampleRate","codec","ignore","bext","Object","keys","forEach","key","addTag","bextRemaining","listHeader","listType","parseRiffInfoTags","then","valueToken","value","util","id"],"sourceRoot":""}