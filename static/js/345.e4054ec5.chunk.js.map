{"version":3,"file":"static/js/345.e4054ec5.chunk.js","mappings":"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","sources":["../node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js","../node_modules/music-metadata/lib/mpeg/ReplayGainDataFormat.js","../node_modules/music-metadata/lib/mpeg/ExtendedLameHeader.js","../node_modules/music-metadata/lib/mpeg/XingTag.js","../node_modules/music-metadata/lib/mpeg/MpegParser.js"],"sourcesContent":["import { EndOfStreamError } from 'strtok3';\nimport initDebug from 'debug';\nimport { ID3v2Header } from './ID3v2Token.js';\nimport { ID3v2Parser } from './ID3v2Parser.js';\nimport { ID3v1Parser } from '../id3v1/ID3v1Parser.js';\nimport { BasicParser } from '../common/BasicParser.js';\nconst debug = initDebug('music-metadata:parser:ID3');\n/**\n * Abstract parser which tries take ID3v2 and ID3v1 headers.\n */\nexport class AbstractID3Parser extends BasicParser {\n    constructor() {\n        super(...arguments);\n        this.id3parser = new ID3v2Parser();\n    }\n    static async startsWithID3v2Header(tokenizer) {\n        return (await tokenizer.peekToken(ID3v2Header)).fileIdentifier === 'ID3';\n    }\n    async parse() {\n        try {\n            await this.parseID3v2();\n        }\n        catch (err) {\n            if (err instanceof EndOfStreamError) {\n                debug(\"End-of-stream\");\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    finalize() {\n        return;\n    }\n    async parseID3v2() {\n        await this.tryReadId3v2Headers();\n        debug('End of ID3v2 header, go to MPEG-parser: pos=%s', this.tokenizer.position);\n        await this.postId3v2Parse();\n        if (this.options.skipPostHeaders && this.metadata.hasAny()) {\n            this.finalize();\n        }\n        else {\n            const id3v1parser = new ID3v1Parser(this.metadata, this.tokenizer, this.options);\n            await id3v1parser.parse();\n            this.finalize();\n        }\n    }\n    async tryReadId3v2Headers() {\n        const id3Header = await this.tokenizer.peekToken(ID3v2Header);\n        if (id3Header.fileIdentifier === 'ID3') {\n            debug('Found ID3v2 header, pos=%s', this.tokenizer.position);\n            await this.id3parser.parse(this.metadata, this.tokenizer, this.options);\n            return this.tryReadId3v2Headers();\n        }\n    }\n}\n//# sourceMappingURL=AbstractID3Parser.js.map","import * as common from '../common/Util.js';\n/**\n * https://github.com/Borewit/music-metadata/wiki/Replay-Gain-Data-Format#name-code\n */\nvar NameCode;\n(function (NameCode) {\n    /**\n     * not set\n     */\n    NameCode[NameCode[\"not_set\"] = 0] = \"not_set\";\n    /**\n     * Radio Gain Adjustment\n     */\n    NameCode[NameCode[\"radio\"] = 1] = \"radio\";\n    /**\n     * Audiophile Gain Adjustment\n     */\n    NameCode[NameCode[\"audiophile\"] = 2] = \"audiophile\";\n})(NameCode || (NameCode = {}));\n/**\n * https://github.com/Borewit/music-metadata/wiki/Replay-Gain-Data-Format#originator-code\n */\nvar ReplayGainOriginator;\n(function (ReplayGainOriginator) {\n    /**\n     * Replay Gain unspecified\n     */\n    ReplayGainOriginator[ReplayGainOriginator[\"unspecified\"] = 0] = \"unspecified\";\n    /**\n     * Replay Gain pre-set by artist/producer/mastering engineer\n     */\n    ReplayGainOriginator[ReplayGainOriginator[\"engineer\"] = 1] = \"engineer\";\n    /**\n     * Replay Gain set by user\n     */\n    ReplayGainOriginator[ReplayGainOriginator[\"user\"] = 2] = \"user\";\n    /**\n     * Replay Gain determined automatically, as described on this site\n     */\n    ReplayGainOriginator[ReplayGainOriginator[\"automatic\"] = 3] = \"automatic\";\n    /**\n     * Set by simple RMS average\n     */\n    ReplayGainOriginator[ReplayGainOriginator[\"rms_average\"] = 4] = \"rms_average\";\n})(ReplayGainOriginator || (ReplayGainOriginator = {}));\n/**\n * Replay Gain Data Format\n *\n * https://github.com/Borewit/music-metadata/wiki/Replay-Gain-Data-Format\n */\nexport const ReplayGain = {\n    len: 2,\n    get: (buf, off) => {\n        const gain_type = common.getBitAllignedNumber(buf, off, 0, 3);\n        const sign = common.getBitAllignedNumber(buf, off, 6, 1);\n        const gain_adj = common.getBitAllignedNumber(buf, off, 7, 9) / 10.0;\n        if (gain_type > 0) {\n            return {\n                type: common.getBitAllignedNumber(buf, off, 0, 3),\n                origin: common.getBitAllignedNumber(buf, off, 3, 3),\n                adjustment: (sign ? -gain_adj : gain_adj)\n            };\n        }\n        return undefined;\n    }\n};\n//# sourceMappingURL=ReplayGainDataFormat.js.map","/**\n * Extended Lame Header\n */\nimport * as Token from 'token-types';\nimport * as common from '../common/Util.js';\nimport { ReplayGain } from './ReplayGainDataFormat.js';\n/**\n * Info Tag\n * @link http://gabriel.mp3-tech.org/mp3infotag.html\n * @link https://github.com/quodlibet/mutagen/blob/abd58ee58772224334a18817c3fb31103572f70e/mutagen/mp3/_util.py#L112\n */\nexport const ExtendedLameHeader = {\n    len: 27,\n    get: (buf, off) => {\n        const track_peak = Token.UINT32_BE.get(buf, off + 2);\n        return {\n            revision: common.getBitAllignedNumber(buf, off, 0, 4),\n            vbr_method: common.getBitAllignedNumber(buf, off, 4, 4),\n            lowpass_filter: 100 * Token.UINT8.get(buf, off + 1),\n            track_peak: track_peak === 0 ? null : track_peak / 2 ** 23,\n            track_gain: ReplayGain.get(buf, 6),\n            album_gain: ReplayGain.get(buf, 8),\n            music_length: Token.UINT32_BE.get(buf, off + 20),\n            music_crc: Token.UINT8.get(buf, off + 24),\n            header_crc: Token.UINT16_BE.get(buf, off + 24)\n        };\n    }\n};\n//# sourceMappingURL=ExtendedLameHeader.js.map","import * as Token from 'token-types';\nimport * as util from '../common/Util.js';\nimport { ExtendedLameHeader } from './ExtendedLameHeader.js';\n/**\n * Info Tag: Xing, LAME\n */\nexport const InfoTagHeaderTag = new Token.StringType(4, 'ascii');\n/**\n * LAME TAG value\n * Did not find any official documentation for this\n * Value e.g.: \"3.98.4\"\n */\nexport const LameEncoderVersion = new Token.StringType(6, 'ascii');\n/**\n * Info Tag\n * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\n */\nexport const XingHeaderFlags = {\n    len: 4,\n    get: (buf, off) => {\n        return {\n            frames: util.isBitSet(buf, off, 31),\n            bytes: util.isBitSet(buf, off, 30),\n            toc: util.isBitSet(buf, off, 29),\n            vbrScale: util.isBitSet(buf, off, 28)\n        };\n    }\n};\n// /**\n//  * XING Header Tag\n//  * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\n//  */\nexport async function readXingHeader(tokenizer) {\n    const flags = await tokenizer.readToken(XingHeaderFlags);\n    const xingInfoTag = { numFrames: null, streamSize: null, vbrScale: null };\n    if (flags.frames) {\n        xingInfoTag.numFrames = await tokenizer.readToken(Token.UINT32_BE);\n    }\n    if (flags.bytes) {\n        xingInfoTag.streamSize = await tokenizer.readToken(Token.UINT32_BE);\n    }\n    if (flags.toc) {\n        xingInfoTag.toc = new Uint8Array(100);\n        await tokenizer.readBuffer(xingInfoTag.toc);\n    }\n    if (flags.vbrScale) {\n        xingInfoTag.vbrScale = await tokenizer.readToken(Token.UINT32_BE);\n    }\n    const lameTag = await tokenizer.peekToken(new Token.StringType(4, 'ascii'));\n    if (lameTag === 'LAME') {\n        await tokenizer.ignore(4);\n        xingInfoTag.lame = {\n            version: await tokenizer.readToken(new Token.StringType(5, 'ascii'))\n        };\n        const match = xingInfoTag.lame.version.match(/\\d+.\\d+/g);\n        if (match !== null) {\n            const majorMinorVersion = match[0]; // e.g. 3.97\n            const version = majorMinorVersion.split('.').map(n => Number.parseInt(n, 10));\n            if (version[0] >= 3 && version[1] >= 90) {\n                xingInfoTag.lame.extended = await tokenizer.readToken(ExtendedLameHeader);\n            }\n        }\n    }\n    return xingInfoTag;\n}\n//# sourceMappingURL=XingTag.js.map","import * as Token from 'token-types';\nimport { EndOfStreamError } from 'strtok3';\nimport initDebug from 'debug';\nimport * as common from '../common/Util.js';\nimport { AbstractID3Parser } from '../id3v2/AbstractID3Parser.js';\nimport { InfoTagHeaderTag, LameEncoderVersion, readXingHeader } from './XingTag.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nconst debug = initDebug('music-metadata:parser:mpeg');\nexport class MpegContentError extends makeUnexpectedFileContentError('MPEG') {\n}\n/**\n * Cache buffer size used for searching synchronization preabmle\n */\nconst maxPeekLen = 1024;\n/**\n * MPEG-4 Audio definitions\n * Ref:  https://wiki.multimedia.cx/index.php/MPEG-4_Audio\n */\nconst MPEG4 = {\n    /**\n     * Audio Object Types\n     */\n    AudioObjectTypes: [\n        'AAC Main',\n        'AAC LC', // Low Complexity\n        'AAC SSR', // Scalable Sample Rate\n        'AAC LTP' // Long Term Prediction\n    ],\n    /**\n     * Sampling Frequencies\n     * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies\n     */\n    SamplingFrequencies: [\n        96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350, null, null, -1\n    ]\n    /**\n     * Channel Configurations\n     */\n};\nconst MPEG4_ChannelConfigurations = [\n    undefined,\n    ['front-center'],\n    ['front-left', 'front-right'],\n    ['front-center', 'front-left', 'front-right'],\n    ['front-center', 'front-left', 'front-right', 'back-center'],\n    ['front-center', 'front-left', 'front-right', 'back-left', 'back-right'],\n    ['front-center', 'front-left', 'front-right', 'back-left', 'back-right', 'LFE-channel'],\n    ['front-center', 'front-left', 'front-right', 'side-left', 'side-right', 'back-left', 'back-right', 'LFE-channel']\n];\n/**\n * MPEG Audio Layer I/II/III frame header\n * Ref: https://www.mp3-tech.org/programmer/frame_header.html\n * Bit layout: AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM\n * Ref: https://wiki.multimedia.cx/index.php/ADTS\n */\nclass MpegFrameHeader {\n    constructor(buf, off) {\n        // E(15,12): Bitrate index\n        this.bitrateIndex = null;\n        // F(11,10): Sampling rate frequency index\n        this.sampRateFreqIndex = null;\n        // G(9): Padding bit\n        this.padding = null;\n        // H(8): Private bit\n        this.privateBit = null;\n        // I(7,6): Channel Mode\n        this.channelModeIndex = null;\n        // J(5,4): Mode extension (Only used in Joint stereo)\n        this.modeExtension = null;\n        // L(2): Original\n        this.isOriginalMedia = null;\n        this.version = null;\n        this.bitrate = null;\n        this.samplingRate = null;\n        this.frameLength = 0;\n        // B(20,19): MPEG Audio versionIndex ID\n        this.versionIndex = common.getBitAllignedNumber(buf, off + 1, 3, 2);\n        // C(18,17): Layer description\n        this.layer = MpegFrameHeader.LayerDescription[common.getBitAllignedNumber(buf, off + 1, 5, 2)];\n        if (this.versionIndex > 1 && this.layer === 0) {\n            this.parseAdtsHeader(buf, off); // Audio Data Transport Stream (ADTS)\n        }\n        else {\n            this.parseMpegHeader(buf, off); // Conventional MPEG header\n        }\n        // D(16): Protection bit (if true 16-bit CRC follows header)\n        this.isProtectedByCRC = !common.isBitSet(buf, off + 1, 7);\n    }\n    calcDuration(numFrames) {\n        return this.samplingRate == null ? null : (numFrames * this.calcSamplesPerFrame() / this.samplingRate);\n    }\n    calcSamplesPerFrame() {\n        return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];\n    }\n    calculateSideInfoLength() {\n        if (this.layer !== 3)\n            return 2;\n        if (this.channelModeIndex === 3) {\n            // mono\n            if (this.version === 1) {\n                return 17;\n            }\n            if (this.version === 2 || this.version === 2.5) {\n                return 9;\n            }\n        }\n        else {\n            if (this.version === 1) {\n                return 32;\n            }\n            if (this.version === 2 || this.version === 2.5) {\n                return 17;\n            }\n        }\n        return null;\n    }\n    calcSlotSize() {\n        return [null, 4, 1, 1][this.layer];\n    }\n    parseMpegHeader(buf, off) {\n        this.container = 'MPEG';\n        // E(15,12): Bitrate index\n        this.bitrateIndex = common.getBitAllignedNumber(buf, off + 2, 0, 4);\n        // F(11,10): Sampling rate frequency index\n        this.sampRateFreqIndex = common.getBitAllignedNumber(buf, off + 2, 4, 2);\n        // G(9): Padding bit\n        this.padding = common.isBitSet(buf, off + 2, 6);\n        // H(8): Private bit\n        this.privateBit = common.isBitSet(buf, off + 2, 7);\n        // I(7,6): Channel Mode\n        this.channelModeIndex = common.getBitAllignedNumber(buf, off + 3, 0, 2);\n        // J(5,4): Mode extension (Only used in Joint stereo)\n        this.modeExtension = common.getBitAllignedNumber(buf, off + 3, 2, 2);\n        // K(3): Copyright\n        this.isCopyrighted = common.isBitSet(buf, off + 3, 4);\n        // L(2): Original\n        this.isOriginalMedia = common.isBitSet(buf, off + 3, 5);\n        // M(3): The original bit indicates, if it is set, that the frame is located on its original media.\n        this.emphasis = common.getBitAllignedNumber(buf, off + 3, 7, 2);\n        this.version = MpegFrameHeader.VersionID[this.versionIndex];\n        this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];\n        this.codec = `MPEG ${this.version} Layer ${this.layer}`;\n        // Calculate bitrate\n        const bitrateInKbps = this.calcBitrate();\n        if (!bitrateInKbps) {\n            throw new MpegContentError('Cannot determine bit-rate');\n        }\n        this.bitrate = bitrateInKbps * 1000;\n        // Calculate sampling rate\n        this.samplingRate = this.calcSamplingRate();\n        if (this.samplingRate == null) {\n            throw new MpegContentError('Cannot determine sampling-rate');\n        }\n    }\n    parseAdtsHeader(buf, off) {\n        debug(\"layer=0 => ADTS\");\n        this.version = this.versionIndex === 2 ? 4 : 2;\n        this.container = `ADTS/MPEG-${this.version}`;\n        const profileIndex = common.getBitAllignedNumber(buf, off + 2, 0, 2);\n        this.codec = 'AAC';\n        this.codecProfile = MPEG4.AudioObjectTypes[profileIndex];\n        debug(`MPEG-4 audio-codec=${this.codec}`);\n        const samplingFrequencyIndex = common.getBitAllignedNumber(buf, off + 2, 2, 4);\n        this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex];\n        debug(`sampling-rate=${this.samplingRate}`);\n        const channelIndex = common.getBitAllignedNumber(buf, off + 2, 7, 3);\n        this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex];\n        debug(`channel-config=${this.mp4ChannelConfig ? this.mp4ChannelConfig.join('+') : '?'}`);\n        this.frameLength = common.getBitAllignedNumber(buf, off + 3, 6, 2) << 11;\n    }\n    calcBitrate() {\n        if (this.bitrateIndex === 0x00 || // free\n            this.bitrateIndex === 0x0F) { // reserved\n            return null;\n        }\n        if (this.version && this.bitrateIndex) {\n            const codecIndex = 10 * Math.floor(this.version) + this.layer;\n            return MpegFrameHeader.bitrate_index[this.bitrateIndex][codecIndex];\n        }\n        return null;\n    }\n    calcSamplingRate() {\n        if (this.sampRateFreqIndex === 0x03 || this.version === null || this.sampRateFreqIndex == null)\n            return null; // 'reserved'\n        return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];\n    }\n}\nMpegFrameHeader.SyncByte1 = 0xFF;\nMpegFrameHeader.SyncByte2 = 0xE0;\nMpegFrameHeader.VersionID = [2.5, null, 2, 1];\nMpegFrameHeader.LayerDescription = [0, 3, 2, 1];\nMpegFrameHeader.ChannelMode = ['stereo', 'joint_stereo', 'dual_channel', 'mono'];\nMpegFrameHeader.bitrate_index = {\n    1: { 11: 32, 12: 32, 13: 32, 21: 32, 22: 8, 23: 8 },\n    2: { 11: 64, 12: 48, 13: 40, 21: 48, 22: 16, 23: 16 },\n    3: { 11: 96, 12: 56, 13: 48, 21: 56, 22: 24, 23: 24 },\n    4: { 11: 128, 12: 64, 13: 56, 21: 64, 22: 32, 23: 32 },\n    5: { 11: 160, 12: 80, 13: 64, 21: 80, 22: 40, 23: 40 },\n    6: { 11: 192, 12: 96, 13: 80, 21: 96, 22: 48, 23: 48 },\n    7: { 11: 224, 12: 112, 13: 96, 21: 112, 22: 56, 23: 56 },\n    8: { 11: 256, 12: 128, 13: 112, 21: 128, 22: 64, 23: 64 },\n    9: { 11: 288, 12: 160, 13: 128, 21: 144, 22: 80, 23: 80 },\n    10: { 11: 320, 12: 192, 13: 160, 21: 160, 22: 96, 23: 96 },\n    11: { 11: 352, 12: 224, 13: 192, 21: 176, 22: 112, 23: 112 },\n    12: { 11: 384, 12: 256, 13: 224, 21: 192, 22: 128, 23: 128 },\n    13: { 11: 416, 12: 320, 13: 256, 21: 224, 22: 144, 23: 144 },\n    14: { 11: 448, 12: 384, 13: 320, 21: 256, 22: 160, 23: 160 }\n};\nMpegFrameHeader.sampling_rate_freq_index = {\n    1: { 0: 44100, 1: 48000, 2: 32000 },\n    2: { 0: 22050, 1: 24000, 2: 16000 },\n    2.5: { 0: 11025, 1: 12000, 2: 8000 }\n};\nMpegFrameHeader.samplesInFrameTable = [\n    /* Layer   I    II   III */\n    [0, 384, 1152, 1152], // MPEG-1\n    [0, 384, 1152, 576] // MPEG-2(.5\n];\n/**\n * MPEG Audio Layer I/II/III\n */\nconst FrameHeader = {\n    len: 4,\n    get: (buf, off) => {\n        return new MpegFrameHeader(buf, off);\n    }\n};\nfunction getVbrCodecProfile(vbrScale) {\n    return `V${Math.floor((100 - vbrScale) / 10)}`;\n}\nexport class MpegParser extends AbstractID3Parser {\n    constructor() {\n        super(...arguments);\n        this.frameCount = 0;\n        this.syncFrameCount = -1;\n        this.countSkipFrameData = 0;\n        this.totalDataLength = 0;\n        this.bitrates = [];\n        this.offset = 0;\n        this.frame_size = 0;\n        this.crc = null;\n        this.calculateEofDuration = false;\n        this.samplesPerFrame = null;\n        this.buf_frame_header = new Uint8Array(4);\n        /**\n         * Number of bytes already parsed since beginning of stream / file\n         */\n        this.mpegOffset = null;\n        this.syncPeek = {\n            buf: new Uint8Array(maxPeekLen),\n            len: 0\n        };\n    }\n    /**\n     * Called after ID3 headers have been parsed\n     */\n    async postId3v2Parse() {\n        this.metadata.setFormat('lossless', false);\n        try {\n            let quit = false;\n            while (!quit) {\n                await this.sync();\n                quit = await this.parseCommonMpegHeader();\n            }\n        }\n        catch (err) {\n            if (err instanceof EndOfStreamError) {\n                debug(\"End-of-stream\");\n                if (this.calculateEofDuration) {\n                    if (this.samplesPerFrame !== null) {\n                        const numberOfSamples = this.frameCount * this.samplesPerFrame;\n                        this.metadata.setFormat('numberOfSamples', numberOfSamples);\n                        if (this.metadata.format.sampleRate) {\n                            const duration = numberOfSamples / this.metadata.format.sampleRate;\n                            debug(`Calculate duration at EOF: ${duration} sec.`, duration);\n                            this.metadata.setFormat('duration', duration);\n                        }\n                    }\n                }\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    /**\n     * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length\n     */\n    finalize() {\n        const format = this.metadata.format;\n        const hasID3v1 = !!this.metadata.native.ID3v1;\n        if (this.mpegOffset !== null) {\n            if (format.duration && this.tokenizer.fileInfo.size) {\n                const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\n                if (format.codecProfile && format.codecProfile[0] === 'V') {\n                    this.metadata.setFormat('bitrate', mpegSize * 8 / format.duration);\n                }\n            }\n            else if (this.tokenizer.fileInfo.size && format.codecProfile === 'CBR') {\n                const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\n                if (this.frame_size !== null && this.samplesPerFrame !== null) {\n                    const numberOfSamples = Math.round(mpegSize / this.frame_size) * this.samplesPerFrame;\n                    this.metadata.setFormat('numberOfSamples', numberOfSamples);\n                    if (format.sampleRate) {\n                        const duration = numberOfSamples / format.sampleRate;\n                        debug(\"Calculate CBR duration based on file size: %s\", duration);\n                        this.metadata.setFormat('duration', duration);\n                    }\n                }\n            }\n        }\n    }\n    async sync() {\n        let gotFirstSync = false;\n        while (true) {\n            let bo = 0;\n            this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, { length: maxPeekLen, mayBeLess: true });\n            if (this.syncPeek.len <= 163) {\n                throw new EndOfStreamError();\n            }\n            while (true) {\n                if (gotFirstSync && (this.syncPeek.buf[bo] & 0xE0) === 0xE0) {\n                    this.buf_frame_header[0] = MpegFrameHeader.SyncByte1;\n                    this.buf_frame_header[1] = this.syncPeek.buf[bo];\n                    await this.tokenizer.ignore(bo);\n                    debug(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`);\n                    if (this.syncFrameCount === this.frameCount) {\n                        debug(`Re-synced MPEG stream, frameCount=${this.frameCount}`);\n                        this.frameCount = 0;\n                        this.frame_size = 0;\n                    }\n                    this.syncFrameCount = this.frameCount;\n                    return; // sync\n                }\n                gotFirstSync = false;\n                bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo);\n                if (bo === -1) {\n                    if (this.syncPeek.len < this.syncPeek.buf.length) {\n                        throw new EndOfStreamError();\n                    }\n                    await this.tokenizer.ignore(this.syncPeek.len);\n                    break; // continue with next buffer\n                }\n                ++bo;\n                gotFirstSync = true;\n            }\n        }\n    }\n    /**\n     * Combined ADTS & MPEG (MP2 & MP3) header handling\n     * @return {Promise<boolean>} true if parser should quit\n     */\n    async parseCommonMpegHeader() {\n        if (this.frameCount === 0) {\n            this.mpegOffset = this.tokenizer.position - 1;\n        }\n        await this.tokenizer.peekBuffer(this.buf_frame_header, { offset: 1, length: 3 });\n        let header;\n        try {\n            header = FrameHeader.get(this.buf_frame_header, 0);\n        }\n        catch (err) {\n            await this.tokenizer.ignore(1);\n            if (err instanceof Error) {\n                this.metadata.addWarning(`Parse error: ${err.message}`);\n                return false; // sync\n            }\n            throw err;\n        }\n        await this.tokenizer.ignore(3);\n        this.metadata.setFormat('container', header.container);\n        this.metadata.setFormat('codec', header.codec);\n        this.metadata.setFormat('lossless', false);\n        this.metadata.setFormat('sampleRate', header.samplingRate);\n        this.frameCount++;\n        return header.version !== null && header.version >= 2 && header.layer === 0 ? this.parseAdts(header) : this.parseAudioFrameHeader(header);\n    }\n    /**\n     * @return {Promise<boolean>} true if parser should quit\n     */\n    async parseAudioFrameHeader(header) {\n        this.metadata.setFormat('numberOfChannels', header.channelMode === 'mono' ? 1 : 2);\n        this.metadata.setFormat('bitrate', header.bitrate);\n        if (this.frameCount < 20 * 10000) {\n            debug('offset=%s MP%s bitrate=%s sample-rate=%s', this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);\n        }\n        const slot_size = header.calcSlotSize();\n        if (slot_size === null) {\n            throw new MpegContentError('invalid slot_size');\n        }\n        const samples_per_frame = header.calcSamplesPerFrame();\n        debug(`samples_per_frame=${samples_per_frame}`);\n        const bps = samples_per_frame / 8.0;\n        if (header.bitrate !== null && header.samplingRate != null) {\n            const fsize = (bps * header.bitrate / header.samplingRate) + ((header.padding) ? slot_size : 0);\n            this.frame_size = Math.floor(fsize);\n        }\n        this.audioFrameHeader = header;\n        if (header.bitrate !== null) {\n            this.bitrates.push(header.bitrate);\n        }\n        // xtra header only exists in first frame\n        if (this.frameCount === 1) {\n            this.offset = FrameHeader.len;\n            await this.skipSideInformation();\n            return false;\n        }\n        if (this.frameCount === 3) {\n            // the stream is CBR if the first 3 frame bitrates are the same\n            if (this.areAllSame(this.bitrates)) {\n                // Actual calculation will be done in finalize\n                this.samplesPerFrame = samples_per_frame;\n                this.metadata.setFormat('codecProfile', 'CBR');\n                if (this.tokenizer.fileInfo.size)\n                    return true; // Will calculate duration based on the file size\n            }\n            else if (this.metadata.format.duration) {\n                return true; // We already got the duration, stop processing MPEG stream any further\n            }\n            if (!this.options.duration) {\n                return true; // Enforce duration not enabled, stop processing entire stream\n            }\n        }\n        // once we know the file is VBR attach listener to end of\n        // stream so we can do the duration calculation when we\n        // have counted all the frames\n        if (this.options.duration && this.frameCount === 4) {\n            this.samplesPerFrame = samples_per_frame;\n            this.calculateEofDuration = true;\n        }\n        this.offset = 4;\n        if (header.isProtectedByCRC) {\n            await this.parseCrc();\n            return false;\n        }\n        await this.skipSideInformation();\n        return false;\n    }\n    async parseAdts(header) {\n        const buf = new Uint8Array(3);\n        await this.tokenizer.readBuffer(buf);\n        header.frameLength += common.getBitAllignedNumber(buf, 0, 0, 11);\n        this.totalDataLength += header.frameLength;\n        this.samplesPerFrame = 1024;\n        if (header.samplingRate !== null) {\n            const framesPerSec = header.samplingRate / this.samplesPerFrame;\n            const bytesPerFrame = this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount;\n            const bitrate = 8 * bytesPerFrame * framesPerSec + 0.5;\n            this.metadata.setFormat('bitrate', bitrate);\n            debug(`frame-count=${this.frameCount}, size=${header.frameLength} bytes, bit-rate=${bitrate}`);\n        }\n        await this.tokenizer.ignore(header.frameLength > 7 ? header.frameLength - 7 : 1);\n        // Consume remaining header and frame data\n        if (this.frameCount === 3) {\n            this.metadata.setFormat('codecProfile', header.codecProfile);\n            if (header.mp4ChannelConfig) {\n                this.metadata.setFormat('numberOfChannels', header.mp4ChannelConfig.length);\n            }\n            if (this.options.duration) {\n                this.calculateEofDuration = true;\n            }\n            else {\n                return true; // Stop parsing after the third frame\n            }\n        }\n        return false;\n    }\n    async parseCrc() {\n        this.crc = await this.tokenizer.readNumber(Token.INT16_BE);\n        this.offset += 2;\n        return this.skipSideInformation();\n    }\n    async skipSideInformation() {\n        if (this.audioFrameHeader) {\n            const sideinfo_length = this.audioFrameHeader.calculateSideInfoLength();\n            if (sideinfo_length !== null) {\n                await this.tokenizer.readToken(new Token.Uint8ArrayType(sideinfo_length));\n                // side information\n                this.offset += sideinfo_length;\n                await this.readXtraInfoHeader();\n                return;\n            }\n        }\n    }\n    async readXtraInfoHeader() {\n        const headerTag = await this.tokenizer.readToken(InfoTagHeaderTag);\n        this.offset += InfoTagHeaderTag.len; // 12\n        switch (headerTag) {\n            case 'Info':\n                this.metadata.setFormat('codecProfile', 'CBR');\n                return this.readXingInfoHeader();\n            case 'Xing': {\n                const infoTag = await this.readXingInfoHeader();\n                if (infoTag.vbrScale !== null) {\n                    const codecProfile = getVbrCodecProfile(infoTag.vbrScale);\n                    this.metadata.setFormat('codecProfile', codecProfile);\n                }\n                return null;\n            }\n            case 'Xtra':\n                // ToDo: ???\n                break;\n            case 'LAME': {\n                const version = await this.tokenizer.readToken(LameEncoderVersion);\n                if (this.frame_size !== null && this.frame_size >= this.offset + LameEncoderVersion.len) {\n                    this.offset += LameEncoderVersion.len;\n                    this.metadata.setFormat('tool', `LAME ${version}`);\n                    await this.skipFrameData(this.frame_size - this.offset);\n                    return null;\n                }\n                this.metadata.addWarning('Corrupt LAME header');\n                break;\n            }\n            // ToDo: ???\n        }\n        // ToDo: promise duration???\n        const frameDataLeft = this.frame_size - this.offset;\n        if (frameDataLeft < 0) {\n            this.metadata.addWarning(`Frame ${this.frameCount}corrupt: negative frameDataLeft`);\n        }\n        else {\n            await this.skipFrameData(frameDataLeft);\n        }\n        return null;\n    }\n    /**\n     * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\n     * @returns {Promise<string>}\n     */\n    async readXingInfoHeader() {\n        const offset = this.tokenizer.position;\n        const infoTag = await readXingHeader(this.tokenizer);\n        this.offset += this.tokenizer.position - offset;\n        if (infoTag.lame) {\n            this.metadata.setFormat('tool', `LAME ${common.stripNulls(infoTag.lame.version)}`);\n            if (infoTag.lame.extended) {\n                // this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain);\n                this.metadata.setFormat('trackPeakLevel', infoTag.lame.extended.track_peak);\n                if (infoTag.lame.extended.track_gain) {\n                    this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain.adjustment);\n                }\n                if (infoTag.lame.extended.album_gain) {\n                    this.metadata.setFormat('albumGain', infoTag.lame.extended.album_gain.adjustment);\n                }\n                this.metadata.setFormat('duration', infoTag.lame.extended.music_length / 1000);\n            }\n        }\n        if (infoTag.streamSize && this.audioFrameHeader && infoTag.numFrames !== null) {\n            const duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);\n            this.metadata.setFormat('duration', duration);\n            debug('Get duration from Xing header: %s', this.metadata.format.duration);\n            return infoTag;\n        }\n        // frames field is not present\n        const frameDataLeft = this.frame_size - this.offset;\n        await this.skipFrameData(frameDataLeft);\n        return infoTag;\n    }\n    async skipFrameData(frameDataLeft) {\n        if (frameDataLeft < 0)\n            throw new MpegContentError('frame-data-left cannot be negative');\n        await this.tokenizer.ignore(frameDataLeft);\n        this.countSkipFrameData += frameDataLeft;\n    }\n    areAllSame(array) {\n        const first = array[0];\n        return array.every(element => {\n            return element === first;\n        });\n    }\n}\n//# sourceMappingURL=MpegParser.js.map"],"names":["debug","initDebug","AbstractID3Parser","BasicParser","constructor","super","arguments","this","id3parser","ID3v2Parser","startsWithID3v2Header","tokenizer","peekToken","ID3v2Header","fileIdentifier","parse","parseID3v2","err","EndOfStreamError","finalize","tryReadId3v2Headers","position","postId3v2Parse","options","skipPostHeaders","metadata","hasAny","id3v1parser","ID3v1Parser","NameCode","ReplayGainOriginator","ReplayGain","get","buf","off","gain_type","common","sign","gain_adj","type","origin","adjustment","ExtendedLameHeader","len","track_peak","Token","revision","vbr_method","lowpass_filter","track_gain","album_gain","music_length","music_crc","header_crc","InfoTagHeaderTag","LameEncoderVersion","XingHeaderFlags","frames","util","bytes","toc","vbrScale","MpegContentError","makeUnexpectedFileContentError","MPEG4","AudioObjectTypes","SamplingFrequencies","MPEG4_ChannelConfigurations","undefined","MpegFrameHeader","bitrateIndex","sampRateFreqIndex","padding","privateBit","channelModeIndex","modeExtension","isOriginalMedia","version","bitrate","samplingRate","frameLength","versionIndex","layer","LayerDescription","parseAdtsHeader","parseMpegHeader","isProtectedByCRC","calcDuration","numFrames","calcSamplesPerFrame","samplesInFrameTable","calculateSideInfoLength","calcSlotSize","container","isCopyrighted","emphasis","VersionID","channelMode","ChannelMode","codec","bitrateInKbps","calcBitrate","calcSamplingRate","profileIndex","codecProfile","samplingFrequencyIndex","channelIndex","mp4ChannelConfig","join","codecIndex","Math","floor","bitrate_index","sampling_rate_freq_index","SyncByte1","SyncByte2","FrameHeader","MpegParser","frameCount","syncFrameCount","countSkipFrameData","totalDataLength","bitrates","offset","frame_size","crc","calculateEofDuration","samplesPerFrame","buf_frame_header","Uint8Array","mpegOffset","syncPeek","setFormat","quit","sync","parseCommonMpegHeader","numberOfSamples","format","sampleRate","duration","hasID3v1","native","ID3v1","fileInfo","size","mpegSize","round","gotFirstSync","bo","peekBuffer","length","mayBeLess","ignore","indexOf","header","Error","addWarning","message","parseAdts","parseAudioFrameHeader","slot_size","samples_per_frame","bps","fsize","audioFrameHeader","push","skipSideInformation","areAllSame","parseCrc","readBuffer","framesPerSec","readNumber","sideinfo_length","readToken","readXtraInfoHeader","headerTag","readXingInfoHeader","infoTag","skipFrameData","frameDataLeft","async","flags","xingInfoTag","streamSize","lame","match","split","map","n","Number","parseInt","extended","readXingHeader","array","first","every","element"],"sourceRoot":""}