{"version":3,"file":"static/js/309.2e3697e5.chunk.js","mappings":"gLAMO,MAAMA,EAAc,CACvBC,IAAK,EACLC,IAAKA,CAACC,EAAKC,KACA,CACHC,WAAWC,EAAAA,EAAAA,IAAqBH,EAAKC,EAAK,EAAG,MCNnDG,EAAQC,EAAU,6BAMlBC,EAAe,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAIpE,MAAMC,UAAkBC,EAAAA,EAC3B,WAAMC,GAEF,GAAgB,gBADMC,KAAKC,UAAUC,UAAU,IAAIC,EAAAA,eAAe,IAE9D,MAAM,IAAIC,MAAM,0CAEpBJ,KAAKK,SAASC,UAAU,YAAa,OACrCN,KAAKK,SAASC,UAAU,QAAS,OACjCN,KAAKK,SAASC,UAAU,aAAc,KACtCN,KAAKK,SAASC,UAAU,UAAW,MACnCN,KAAKK,SAASC,UAAU,mBAAoB,GAC5C,IAAIC,EAAa,EACbC,EAAS,EACb,MAAMC,EAAoBT,KAAKC,UAAUS,UAAUC,MAAQC,OAAOC,iBAClE,GAAIb,KAAKc,QAAQC,SAAU,CACvB,KAAOf,KAAKC,UAAUe,SAAWP,GAAmB,CAChD,MAAMQ,QAAejB,KAAKC,UAAUC,UAAUf,GAExCwB,EAAOf,EAAaqB,EAAOzB,WACjC,GAAImB,EAAO,EAAG,CAEV,GADAJ,GAAcI,EAAO,EACjBJ,EAAaE,EACb,YACET,KAAKC,UAAUiB,OAAOP,KAC1BH,CACN,MAEId,EAAM,oCAAoCuB,EAAOzB,sBAEzD,CACAQ,KAAKK,SAASC,UAAU,WAAqB,IAATE,EACxC,CACJ,E","sources":["../node_modules/music-metadata/lib/amr/AmrToken.js","../node_modules/music-metadata/lib/amr/AmrParser.js"],"sourcesContent":["import { getBitAllignedNumber } from '../common/Util.js';\n/**\n * ID3v2 header\n * Ref: http://id3.org/id3v2.3.0#ID3v2_header\n * ToDo\n */\nexport const FrameHeader = {\n    len: 1,\n    get: (buf, off) => {\n        return {\n            frameType: getBitAllignedNumber(buf, off, 1, 4)\n        };\n    }\n};\n//# sourceMappingURL=AmrToken.js.map","import { BasicParser } from '../common/BasicParser.js';\nimport { AnsiStringType } from 'token-types';\nimport initDebug from 'debug';\nimport { FrameHeader } from './AmrToken.js';\nconst debug = initDebug('music-metadata:parser:AMR');\n/**\n * There are 8 varying levels of compression. First byte of the frame specifies CMR\n * (codec mode request), values 0-7 are valid for AMR. Each mode have different frame size.\n * This table reflects that fact.\n */\nconst m_block_size = [12, 13, 15, 17, 19, 20, 26, 31, 5, 0, 0, 0, 0, 0, 0, 0];\n/**\n * Adaptive Multi-Rate audio codec\n */\nexport class AmrParser extends BasicParser {\n    async parse() {\n        const magicNr = await this.tokenizer.readToken(new AnsiStringType(5));\n        if (magicNr !== '#!AMR') {\n            throw new Error('Invalid AMR file: invalid MAGIC number');\n        }\n        this.metadata.setFormat('container', 'AMR');\n        this.metadata.setFormat('codec', 'AMR');\n        this.metadata.setFormat('sampleRate', 8000);\n        this.metadata.setFormat('bitrate', 64000);\n        this.metadata.setFormat('numberOfChannels', 1);\n        let total_size = 0;\n        let frames = 0;\n        const assumedFileLength = this.tokenizer.fileInfo?.size ?? Number.MAX_SAFE_INTEGER;\n        if (this.options.duration) {\n            while (this.tokenizer.position < assumedFileLength) {\n                const header = await this.tokenizer.readToken(FrameHeader);\n                /* first byte is rate mode. each rate mode has frame of given length. look it up. */\n                const size = m_block_size[header.frameType];\n                if (size > 0) {\n                    total_size += size + 1;\n                    if (total_size > assumedFileLength)\n                        break;\n                    await this.tokenizer.ignore(size);\n                    ++frames;\n                }\n                else {\n                    debug(`Found no-data frame, frame-type: ${header.frameType}. Skipping`);\n                }\n            }\n            this.metadata.setFormat('duration', frames * 0.02);\n        }\n    }\n}\n//# sourceMappingURL=AmrParser.js.map"],"names":["FrameHeader","len","get","buf","off","frameType","getBitAllignedNumber","debug","initDebug","m_block_size","AmrParser","BasicParser","parse","this","tokenizer","readToken","AnsiStringType","Error","metadata","setFormat","total_size","frames","assumedFileLength","fileInfo","size","Number","MAX_SAFE_INTEGER","options","duration","position","header","ignore"],"sourceRoot":""}